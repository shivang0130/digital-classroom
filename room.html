<!DOCTYPE html>
<html>
<head>
  <title>Multi-User WebRTC Room</title>
  <style>
    video {
      width: 200px;
      height: 150px;
      margin: 5px;
      border: 2px solid #4CAF50;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <h2>Multi-User Video Room</h2>
  <video id="localVideo" autoplay muted></video>
  <div id="remoteVideos"></div>

  <script>
    const socket = new WebSocket("wss://polar-maroon-barnacle.glitch.me"); // Your signaling server
    const peers = {}; // socketId -> RTCPeerConnection
    let localStream;

    // Get user media
    navigator.mediaDevices.getUserMedia({ video: true, audio: true })
      .then(stream => {
        localStream = stream;
        document.getElementById("localVideo").srcObject = stream;
        sendToServer({ type: "join-room" });
      });

    socket.onmessage = (event) => {
      const data = JSON.parse(event.data);

      switch (data.type) {
        case "new-user":
          if (!peers[data.socketId]) createOffer(data.socketId);
          break;
        case "offer":
          createAnswer(data.offer, data.socketId);
          break;
        case "answer":
          peers[data.socketId].setRemoteDescription(new RTCSessionDescription(data.answer));
          break;
        case "candidate":
          peers[data.socketId].addIceCandidate(new RTCIceCandidate(data.candidate));
          break;
      }
    };

    function sendToServer(msg) {
      socket.send(JSON.stringify(msg));
    }

    function createOffer(socketId) {
      const peer = new RTCPeerConnection();
      peers[socketId] = peer;

      localStream.getTracks().forEach(track => peer.addTrack(track, localStream));

      peer.onicecandidate = event => {
        if (event.candidate) {
          sendToServer({ type: "candidate", candidate: event.candidate, socketId });
        }
      };

      peer.ontrack = event => addRemoteVideo(socketId, event.streams[0]);

      peer.createOffer().then(offer => {
        return peer.setLocalDescription(offer);
      }).then(() => {
        sendToServer({ type: "offer", offer: peer.localDescription, socketId });
      });
    }

    function createAnswer(offer, socketId) {
      const peer = new RTCPeerConnection();
      peers[socketId] = peer;

      localStream.getTracks().forEach(track => peer.addTrack(track, localStream));

      peer.onicecandidate = event => {
        if (event.candidate) {
          sendToServer({ type: "candidate", candidate: event.candidate, socketId });
        }
      };

      peer.ontrack = event => addRemoteVideo(socketId, event.streams[0]);

      peer.setRemoteDescription(new RTCSessionDescription(offer)).then(() => {
        return peer.createAnswer();
      }).then(answer => {
        return peer.setLocalDescription(answer);
      }).then(() => {
        sendToServer({ type: "answer", answer: peer.localDescription, socketId });
      });
    }

    function addRemoteVideo(id, stream) {
      if (!document.getElementById(id)) {
        const video = document.createElement("video");
        video.id = id;
        video.srcObject = stream;
        video.autoplay = true;
        video.playsInline = true;
        document.getElementById("remoteVideos").appendChild(video);
      }
    }
  </script>
</body>
</html>
